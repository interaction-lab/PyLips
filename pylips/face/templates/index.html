<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ face_name | default('Default') }}</title>
    <script src="{{ url_for('static', filename='js/socketio.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/canvasFace.js') }}"></script>
    <script src="{{ url_for('static', filename='js/helpers.js') }}"></script>
    
    <script>
        const name = document.title
        var socket = io();

        socket.on('face_control', function(msg){
            console.log('message to ' + msg.name + ' : ' + msg.action_type);
            if(msg.name != name){
                return
            }

            if (msg.action_type == 'say') {
                play_visemes(msg.visemes, 55, msg.times)
            }

            if (msg.action_type == 'stop_speech') {
                stop_visemes()
            }

            if (msg.action_type == 'look') {
                console.log('Calling lookat');
                lookat(msg.location[0], msg.location[1], msg.location[2], msg.time)
                looking = true //stops the idle movements
            }

            if (msg.action_type == 'release_gaze') {
                looking = false //starts the idle movements
            }

            if (msg.action_type == 'express') {
                time = msg.time
                for (var au_cmd in msg.aus){
                    au_number = parseInt(au_cmd.slice(2))
                    // if the last character is 'l' or 'r', it's a side command
                    // if it is a number, au() will assume both sides
                    side = au_cmd.slice(-1)
                    degree = parseFloat(msg.aus[au_cmd])
                    au(au_number, degree, side, time)
                }
            }

            if(msg.action_type == 'update_face'){

                Object.keys(params).forEach(key => {
                    if(msg.configuration.hasOwnProperty(key)){
                        params[key] = msg.configuration[key]
                    }
                });
            }

        });

        // Handle audio playback from server
        socket.on('play_audio', function(msg){
            console.log('Received audio for:', msg.name);
            
            // Check if this audio is for this face
            if(msg.name != name && msg.name != 'all'){
                return;
            }
            
            // Create audio element and play
            const audioBlob = base64ToBlob(msg.audio_data, msg.mime_type);
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            
            audio.play().then(() => {
                console.log('Playing audio:', msg.filename);
            }).catch(error => {
                console.error('Error playing audio:', error);
            });
            
            // Clean up URL after playing
            audio.addEventListener('ended', () => {
                URL.revokeObjectURL(audioUrl);
            });
        });

        // Helper function to convert base64 to blob
        function base64ToBlob(base64Data, mimeType) {
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], {type: mimeType});
        }

        // Utility functions for external use
        window.playAudioFile = function(filename, targetName = name) {
            socket.emit('play_audio_file', {
                filename: filename,
                name: targetName
            });
        };

        window.getAudioList = function() {
            socket.emit('request_audio_list');
        };

    </script>

</head>
<body>
</body>
</html>

</body>
</html>